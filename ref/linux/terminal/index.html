<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>termianl | ST</title> <meta name="author" content="Sean Trautman"/> <meta name="description" content="Intro to cli terminal commands"/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/st-logo-transparent.png"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://straut12.github.io/ref/linux/terminal/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <div class="site-container"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">ST</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"></a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Coding</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/ref/coding/git/">VScode Github</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/coding/bash/">Bash Shell</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/coding/python/">Python</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/coding/js/">JavaScript</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/coding/html/">Web HTML</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Data Analysis</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/ref/data-analysis/data-collection/">data collection</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/data-analysis/databases/">databases</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/data-analysis/basic-charting/">basic charting</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/data-analysis/data-visualization/">data visualization</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/data-analysis/ml/">machine learning</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/data-analysis/statistics/">notes</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Linux</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/ref/linux/linuxdistros/">Linux Options</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/desktop/">Desktop Appearance</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/software/">Installing SW</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/sharing/">File Sharing</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/vnc-ssh/">Remote vnc ssh</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/terminal/">Terminal cli</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/autostart/">Autostart systemd</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/logs/">Logs</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/ref/linux/list/">List of SW to Install</a> </div> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="site-body wrapper"> <aside class="site-sidebar" id="site-sidebar"> <nav class="toc"> <header><h4 class="toc__title">Table of Contents</h4></header> <ul class="toc__menu"> <li><a href="#sudo-su-root">sudo, su, root</a></li> <li><a href="#make-a-file-executable">Make a File Executable</a></li> <li> <a href="#path">$PATH</a> <ul> <li><a href="#pythonpath">PYTHONPATH</a></li> </ul> </li> <li> <a href="#regexawksedgrep">regex,awk,sed,grep</a> <ul> <li><a href="#regex">regex</a></li> <li><a href="#grep">grep</a></li> <li><a href="#awk">awk</a></li> <li><a href="#sed">sed</a></li> </ul> </li> <li> <a href="#helpful-terminal-commands">Helpful Terminal Commands</a> <ul> <li><a href="#dirfile-commands">Dir/File commands</a></li> <li><a href="#pipegrep">Pipe/grep</a></li> <li><a href="#findmlocate">Find/mlocate</a></li> <li><a href="#globbing">globbing</a></li> </ul> </li> </ul> </nav> </aside> <main> <div class="post"> <p class="post-description">Intro to cli terminal commands</p> <article> <p>The terminal is still an important part of navigating and installing data analysis tools. (cli stands for command line interface).</p> <p>Note- For windows you can use cmd.exe or PowerShell. The Anaconda environment would not activate in PowerShell so I use cmd.exe (updated vscode in command palette. Terminal:Select default profile)</p> <h1 id="sudo-su-root">sudo, su, root</h1> <p>The following assumes you’re either a single user on a Linux distro or Raspberry Pi. By default there are two user names on RPi, “pi” and “root”. (For non RPi systems replace “pi” with your user name entered during install) “pi” is the default user and is a member of the sudo group. This means you can run commands as root using sudo and can switch to the root user with <code class="language-plaintext highlighter-rouge">$ sudo su</code> “root” is the superuser and has complete access.</p> <ul> <li>You can add more users which will create another “home” directory (pi is under /home/pi)</li> <li> <code class="language-plaintext highlighter-rouge">$ su &lt;username&gt;</code> is used to switch between users; logout and login to another. (If no username is specified it will try to login to root but requires root password. See more below)</li> <li> <code class="language-plaintext highlighter-rouge">$ whoami</code> at any point will show you the user currently logged in</li> <li>sudoers file has configurations</li> </ul> <p>When you need superuser/root it is best to use option 1 when possible. Options 2-4 can gain root by “sudo” and stays at that level (but without having to switch the user to root). Also ~/.bash_profile, .profile, .bashrc and /etc/profile will be executed. whoami=root. Only requires user password. Command line will have #. Type ‘exit’ to leave</p> <ol> <li> <code class="language-plaintext highlighter-rouge">$ sudo &lt;command&gt;</code>RECOMMENDED. Temporarily elevate pi user to root privileges. You are still the pi user but have root privileges for one command.</li> <li> <code class="language-plaintext highlighter-rouge">$ sudo -i </code> preferred <strong>root</strong> method due to cleaner interaction with environment variables. Will give you interactive root shell and change to root environment, pwd=/root. (sudo -s will not change environement)</li> <li> <code class="language-plaintext highlighter-rouge">$ sudo su -</code>Logs you into root with the root environment (pwd=/root)</li> <li> <code class="language-plaintext highlighter-rouge">$ sudo su </code> Logs you into root with the your environment (pwd=/home/pi)</li> </ol> <p>If you try <code class="language-plaintext highlighter-rouge">$ su -</code> or <code class="language-plaintext highlighter-rouge">$ su</code> to log into root it will want root password, not user pswd. Disabled on debian (Pi)/ubuntu. (Set or change the root password by running <code class="language-plaintext highlighter-rouge">sudo passwd root</code>)</p> <p>Note on ‘-‘ (or –login) indicates a login shell and will execute commands from the profiles /etc/profile ~/.bash_profile ~/.bash_login ~/.profile</p> <p>when you see ‘#’ - needs to be executed with root privileges either directly as a root user or by use of sudo command</p> <hr> <p><strong>Ownership functions</strong><br> Changing Ownership of a file<br> <code class="language-plaintext highlighter-rouge">$ chown USER:GROUP FILE</code></p> <p>so.. <code class="language-plaintext highlighter-rouge">$ chown &lt;new-user&gt; &lt;file-name&gt;</code><br> <code class="language-plaintext highlighter-rouge">$ chown &lt;new-user&gt;:&lt;new-group&gt; &lt;file-name&gt;</code><br> Change ownership recursively in a directory<br> <code class="language-plaintext highlighter-rouge">$ chown -R &lt;new-user&gt;:&lt;new-group&gt; &lt;directory&gt;</code></p> <hr> <h1 id="make-a-file-executable">Make a File Executable</h1> <p>Making a file executable (+x vs 755)<br> chmod +x adds the execute permission for all users to the existing permissions.<br> The + is telling it to add permissions to what it already has (relative). A - (minus) would remove it.<br> <code class="language-plaintext highlighter-rouge">$ chmod +x file.py</code></p> <p>while chmod 755 says over write all, current permissions with what I’m providing, 755. (absolute)<br> 755 = full permissions for the owner and read and execute permission for others.</p> <p>More details on 755</p> <ul> <li>755 correspond to read/write-execute permissions on a file/dir</li> <li>read = r (4)</li> <li>write = w (2)</li> <li>execute = x (1)</li> <li>When added it is the total permissions</li> </ul> <p>For owner/group/others (ugo) you can set seperate permissions (hence 755)</p> <ul> <li>Owner= read/write/execute = rwx = 4+2+1=7</li> <li>Group= read/execute = r-x = 4+0+1=5</li> <li>Other= read/execute = r-x = 4+0+1=5​</li> </ul> <div class="row"> <div class="col-md mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/linux/ownership.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Example- When you do $ ls -lrt you see a list of files with details. (See screenshot above)<br> Columns<br> 1: ‘-‘ = file. ‘d’ = directory<br> 2: owner (u) permissions<br> 3: group (g) permission<br> 4: other (o) permission<br> (user and group ID are circled after that)</p> <p>Note - using gedit for a file that needs sudo, root privilege (in GNOME)<br> gedit admin:///etc/default/grub</p> <hr> <h1 id="path">$PATH</h1> <p>The understanding of bin/executables and how your system knows where to look for these executables ($PATH) can be useful. $PATH is a system variable that defines what directories will be searched for executables. To see your $PATH setup.<br> <code class="language-plaintext highlighter-rouge">$ echo $PATH | tr ":" "\n"</code></p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">/usr/local/sbin 
/usr/local/bin   
/usr/sbin         
/usr/bin           
/sbin               
/bin                 
</span></code></pre></div></div> <p>As an example, take the executable ‘ls’ used to list contents of a directory. If you do <code class="language-plaintext highlighter-rouge">$ which ls</code> it will output <code class="language-plaintext highlighter-rouge">/bin/ls</code>. Meaning the ‘ls’ executable file is located in /bin/ dir, which is listed in $PATH above. So when you type <code class="language-plaintext highlighter-rouge">$ ls</code> your system knows from $PATH what directories it can search and it will find ‘ls’ in /bin. (If you go to the /bin/ dir and list the contents you will see many command utilities listed)</p> <p>Creating your own simple shell/bash file in a dir, making it executable, and then adding that dir to your $PATH so you can execute it from any location can help understand the concept<br> Example below will be assuming working on a RPi and the home dir = /home/pi (or you can use $HOME)</p> <ul> <li>Create a test dir</li> <li><code class="language-plaintext highlighter-rouge">$ mkdir test</code></li> <li>Create a test file (bash file)</li> <li><code class="language-plaintext highlighter-rouge">$ touch hello</code></li> <li>Add the shebang and echo line to ‘hello’ file to output some txt. (#!/usr/bin/env bash tells the system to use ‘bash’ to run your file)</li> <li><code class="language-plaintext highlighter-rouge">$ nano hello</code></li> <li><code class="language-plaintext highlighter-rouge">#!/usr/bin/env bash</code></li> <li><code class="language-plaintext highlighter-rouge">echo hello</code></li> <li>Now make the ‘hello’ bash file executable with</li> <li><code class="language-plaintext highlighter-rouge">$ chmod +x hello</code></li> <li>As long as you tell the system the location of your bash file you can execute it. For example if you’re in the ‘test’ dir you can run</li> <li><code class="language-plaintext highlighter-rouge">$ ./hello</code></li> <li>(the ‘.’ tells it is in the current, working dir) or if you go to another dir you could execute with</li> <li><code class="language-plaintext highlighter-rouge">$ /home/pi/test/hello</code></li> <li>But if you try and execute it without listing the location of the file (ie $ hello) you will get an error bash: hello: command not found. This is because the system * didn’t know where to look for your ‘hello’ executable file.</li> <li>However if we add the location of the ‘hello’ file (/home/pi/test/) to the $PATH variable it will know where to look and you can execute it without specifying the location.</li> <li>To add /home/pi/test/ to your $PATH type</li> <li><code class="language-plaintext highlighter-rouge">$ export PATH=$PATH:/home/pi/test</code></li> <li>Now you can type</li> <li><code class="language-plaintext highlighter-rouge">$ hello</code></li> <li>from any location or directory and it will execute.</li> <li>NOTE - once you close your terminal it will lose the $PATH update you made and not work anymore. To make it permanent you need to add the ‘export PATH=$PATH:/home/pi/test’ to one of your profiles that are loaded when you open a terminal. (ie .profile or .bashrc)</li> <li>From your home dir type</li> <li><code class="language-plaintext highlighter-rouge">$ nano .bashrc</code></li> <li>add <code class="language-plaintext highlighter-rouge">export PATH=$PATH:/home/pi/test</code> to the bottom of the file and save it.</li> <li>Now when you open a terminal and type <code class="language-plaintext highlighter-rouge">$ hello</code> it will know to look for your executable ‘hello’ script inside /home/pi/test</li> <li>To reload without having to logout/login use <code class="language-plaintext highlighter-rouge">source ~/.bashrc</code> or <code class="language-plaintext highlighter-rouge">. ~/.bashrc</code> </li> <li>To clean up go remove the line.</li> </ul> <p><strong>Setting Environment Variable</strong> You can test out creating your own environement variable</p> <ul> <li><code class="language-plaintext highlighter-rouge">$ export TEST=hello</code></li> <li><code class="language-plaintext highlighter-rouge">$ echo $TEST</code></li> </ul> <p>Again, once you close the session it will not exist. To make it persistent add it to a profile. <strong>Add Env Variable to Profile (.profile or .bashcrc)</strong></p> <ul> <li>Example..</li> <li><code class="language-plaintext highlighter-rouge">$ nano .bashrc</code></li> <li>and add <code class="language-plaintext highlighter-rouge">export TEST=hello</code> </li> <li>Now save ​ <h2 id="pythonpath">PYTHONPATH</h2> <p>Python has a similar path setting that you can use -&gt; PYTHONPATH It will be empty initially. You do not need to set it up, however it can be good practice to understand the PATH concepts. You can create your /bin/ dir where you store your executable python scripts and update the PYTHONPATH so you can run these scripts from any location (without having to specify the full path)</p> </li> </ul> <p>Example below will be assuming working on a RPi and the home dir = /home/pi (or you can use $HOME)</p> <p>Create your own simple executable python file</p> <ul> <li>From your home dir create directories bin and lib/python</li> <li><code class="language-plaintext highlighter-rouge">$ mkdir bin lib</code></li> <li><code class="language-plaintext highlighter-rouge">$ mkdir lib/python</code></li> <li>​​Keep python executable scripts in /bin/</li> <li>Keep python libraries you create in /lib/python</li> <li>Go to the ~/bin/ dir and create a test python script</li> <li><code class="language-plaintext highlighter-rouge">$ touch pyhello.py</code></li> <li>Add the shebang and print line to ‘pyhello’ file to output some txt. (#!/usr/bin/env python3 tells the system to use Python3 to run your file)</li> <li> <code class="language-plaintext highlighter-rouge">$ nano pyhello.py</code> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3 
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">hello from py</span><span class="sh">"</span><span class="p">)</span>     
</code></pre></div> </div> </li> <li>Now make the ‘pyhello.py’ script executable with</li> <li><code class="language-plaintext highlighter-rouge">$ chmod +x pyhello.py</code></li> <li>From your home dir type</li> <li><code class="language-plaintext highlighter-rouge">$ nano .bashrc</code></li> <li>and add these lines at the bottom <div class="language-console highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="gp">PYTHONPATH=$</span>HOME/lib/python 
<span class="go">export PYTHONPATH                        
</span></code></pre></div> </div> </li> <li>Now your own lib/python dir with your Python libraries will be added to your Python path. Reboot your system and your $HOME/bin will be added to your search path.</li> <li>Open a terminal and you can execute pyhello.py from any location.</li> <li> <code class="language-plaintext highlighter-rouge">$ pyhello.py</code> The concept is you can now keep your executable python scripts in ~/bin folder and execute from any location.</li> </ul> <hr> <h1 id="regexawksedgrep">regex,awk,sed,grep</h1> <p>Regular expression (regex), grep, sed, awk<br> Three common Linux commands for text processing are grep, sed, awk. Although there is some overlap each have a strength. The search pattern tool used with them is regular expression or regex.</p> <h2 id="regex">regex</h2> <p>Regular expression is a type of search pattern used with the grep and sed. It allows complex search patterns (special characters are used). Can be used in commands, functions, programming, etc. For example used in Python with the “import re”. Note regex is different than filename “globbing” where ? and * are used as wildcards to find a filename. Link to <a href="https://regex101.com/" target="_blank" rel="noopener noreferrer">regex101</a> testing site</p> <ul> <li>rep - give grep a text input and a “regular expression” and it will search line-by-line looking to match your regex. It will then output every line a match was found.</li> <li>sed - does substituion. give sed a pattern to match and what you want to replace it with.</li> <li>awk - acts as an ad-hoc table or database; separating fields. You can specify which field to output.</li> </ul> <p>To become familiar with the tools it is best to get a text file you want to parse and experiment with the commands. There are many applications (text, log files) but I’ll focus on a sensor report from my PC. This is a common use in conky system monitors.</p> <p>Quick setup guide for lm-sensors. More details at <a href="https://help.ubuntu.com/community/SensorInstallHowto" target="_blank" rel="noopener noreferrer">Ubuntu</a>. First install​​</p> <ul> <li><code class="language-plaintext highlighter-rouge">$ sudo apt install lm-sensors</code></li> <li>You need to load sensor modules.</li> <li><code class="language-plaintext highlighter-rouge">$ sudo sensors-detect</code></li> <li>can edit /etc/sensors.conf</li> <li>See sensors.conf for details</li> <li><code class="language-plaintext highlighter-rouge">$ man sensors.conf</code></li> </ul> <p>You can have the script insert sensor modules into /etc/modules or edit /etc/modules and add what you want. May need to run <code class="language-plaintext highlighter-rouge">$ service kmod start</code></p> <p><code class="language-plaintext highlighter-rouge">$ sensors &gt; sensors.log</code></p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Dell
​Adapter: Virtual device
Processor Fan: 2684 RPM
CPU: +40.0°C
Ambient: +32.0°C
SODIMM: +32.0°C

BAT0-acpi-0
Adapter: ACPI interface
in0: 12.47 V
curr1: 1000.00 uA

coretemp-isa-0000
Adapter: ISA adapter
Package id 0: +41.0°C (high = +87.0°C, crit = +105.0°C)
Core 0: +37.0°C (high = +87.0°C, crit = +105.0°C)
Core 1: +38.0°C (high = +87.0°C, crit = +105.0°C)

acpitz-acpi-0
Adapter: ACPI interface
temp1: +54.5°C (crit = +107.0°C)
</span></code></pre></div></div> <hr> <h2 id="grep">grep</h2> <p>Quick grep example on the sensor.log to find “Core”​<br> ​(see “More about grep” below for details)<br> <code class="language-plaintext highlighter-rouge">$ grep "Core" sensors.log</code><br> Core 0: +37.0°C (high = +87.0°C, crit = +105.0°C)<br> Core 1: +38.0°C (high = +87.0°C, crit = +105.0°C)</p> <p><strong>Details on grep, egrep, agrep</strong> ​​There are many grep options. Here are a few common tools for matching text in a file<br> Don’t forget <code class="language-plaintext highlighter-rouge">$ man grep</code> and <code class="language-plaintext highlighter-rouge">$ info grep</code>​</p> <p>Important note on meta-characters.</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">grep - ‘?’, ‘+’, ‘{’, ‘|’, ‘(’, and ‘)’ lose their special meaning. You need to use blackslashed versions ‘\?’, ‘\+’, ‘\{’, ‘\|’, ‘\(’, and ‘\)’. See gnu.org So OR is \|
egrep - (extended grep) you do not have to backslash. OR is simply | . This makes some expressions easier to view. (examples below)
agrep - does approximate matching. You specifiy how much error with -1, -2. (example below)  
</span></code></pre></div></div> <p>Basic syntax</p> <ul> <li><code class="language-plaintext highlighter-rouge">$ grep [options] pattern [file]</code></li> <li> <code class="language-plaintext highlighter-rouge">$ grep -n "Core" sensors.log</code> Print line numbers where “Core” is found in sensors.log​</li> </ul> <p>More options</p> <ul> <li>-i (not case sensitivie)</li> <li>-w (match the exact word)</li> <li>-v (inverse, show lines without that string)</li> <li>-n display the line number the match was found<br> Returns matching line plus a number of lines before(B), after(A), or both (C)</li> <li>-B 1</li> <li>-A 1</li> <li>-C 1</li> </ul> <p>Pattern expressions</p> <ul> <li>. = match any single character, but must be a character/space there</li> <li>? = preceding item is optional and will be matched at most once​</li> <li>​+ = match preceding character one or more times, but must appear once.</li> <li> <ul> <li>= match preceding character zero, one, more times, but must have a preceding character<br> Play with the * , It’s different than globbing.</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">$ grep * file</code> will have no match (no preceding character to match)</li> <li> <code class="language-plaintext highlighter-rouge">$ grep .* file</code>(and <code class="language-plaintext highlighter-rouge">$ grep "a*"</code>, etc) will match every line</li> <li>^abc starts with “abc”</li> <li>abc$ ends with “abc”</li> <li>(Brackets expressions continue below)</li> </ul> <p>Examples ran on the sensors.log file. Note “egrep” and “agrep” used at the end.<br> egrep used to include multiple words without having to escape the |.<br> agrep has ability to match approximate words (you specify how much error to allow) <br> Example Ambient<br> <code class="language-plaintext highlighter-rouge">$ agrep -1 "Ambent" sensors.log</code><br> -1 = one error<br> <code class="language-plaintext highlighter-rouge">$ agrep -2 "Ambant" sensors.log</code><br> ​-2 = two errors</p> <div class="row"> <div class="col-md mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/linux/grep.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>More egrep<br> To match all the 1’s<br> <code class="language-plaintext highlighter-rouge">$ grep '1' sensors.log</code><br> If I want to include the 1’s that have a + then use the ?=optional on preceding character<br> <code class="language-plaintext highlighter-rouge">$ grep '+\?1' sensors.log</code><br> or I can use egrep and not have to backslash the ?<br> <code class="language-plaintext highlighter-rouge">$ egrep '+?1' sensors.log</code></p> <p>​Brackets - any character in the bracket can be used for matching at that position<br> <code class="language-plaintext highlighter-rouge">$ grep 't[ow]o'</code> file will find “too” and “two”<br> To find various methods of temp (ie 32°C or 32C or 32 C)<br> Search for any number, space or ° before a “C”<br> <code class="language-plaintext highlighter-rouge">​$ grep '[0-9° ]C' sensors.log</code></p> <div class="row"> <div class="col-md mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/linux/grep2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Can use it to find a range of numbers<br> Find any lines with “crit” and then 101. to 106.<br> <code class="language-plaintext highlighter-rouge">$ grep 'crit.*10[1-6]\.' sensors.log</code><br> Package id 0: +41.0°C (high = +87.0°C, crit = +105.0°C)<br> Core 0: +37.0°C (high = +87.0°C, crit = +105.0°C)<br> Core 1: +38.0°C (high = +87.0°C, crit = +105.0°C)</p> <p>To find any line with an opening and closing parenthesis ()<br> <code class="language-plaintext highlighter-rouge">$ grep '(.*)' sensors.log</code><br> To find any line with () but only letters and single space inside, no numbers<br> Note there is a space after the “z”<br> <code class="language-plaintext highlighter-rouge">$ grep '([A-Za-z ]*)' sensors.log</code></p> <p>To find only lines that start with a Capital letter (headings) can use either<br> <code class="language-plaintext highlighter-rouge">$ grep '^[A-Z]' sensors.log</code><br> <code class="language-plaintext highlighter-rouge">$ grep '^[[:upper:]]' sensors.log</code></p> <hr> <h2 id="awk">awk</h2> <p>awk breaks each line into field, based on spaces (default).<br> The whole line is $0, each field is $1, $2, $3 etc.<br> awk [options] script FILE<br> Field ​ 1 2 <strong>3</strong> ….<br> Core 0: <strong>+37.0°C</strong> (high = +87.0°C, crit = +105.0°C)</p> <p>So pipe the output of grep to awk and get field 3, the temp.<br> <code class="language-plaintext highlighter-rouge">$ grep 'Core 0' sensors.log | awk '{print $3}'​</code><br> $3 is the temperature<br> +37.0°C<br> Now use cut to get rid of the “+” sign. Cut from 2nd to 8th char<br> <code class="language-plaintext highlighter-rouge">$ cat sensors.log | grep 'Core 0' | awk '{print $3}' | cut -c2-7</code><br> 37.0°</p> <p>awk is a full programming language with loops, etc. It’s useful because it breaks each line into fields. The whole line is $0, each field is $1, $2, $3 etc.<br> awk [options] script FILE<br> Can print multiple columns<br> <code class="language-plaintext highlighter-rouge">$ awk '{print $1, $2}' sensors.log</code> Default for delimiter is space. Use -F to change it to comma delimited<br> <code class="language-plaintext highlighter-rouge">$ awk -F "," '{print $1, $2}' sensors.log</code><br> To count how many “Cores” we have<br> <code class="language-plaintext highlighter-rouge">$ awk '{count[$1]++} END {print count["Core"]}' sensors.log</code><br> Find column 3 (Core temps) greater than 37.5 and then print the row $0<br> <code class="language-plaintext highlighter-rouge">$ awk '{ if ($3 &gt; 37.5 ) {print $0} }' sensors.log</code></p> <hr> <h2 id="sed">sed</h2> <p>sed can be used to substitute characters. This is useful for harmonizing documents, removing unwanted characters, spaces, etc.<br> <code class="language-plaintext highlighter-rouge">$ man sed and $ info sed</code><br> <code class="language-plaintext highlighter-rouge">$ sed [options] script FILE</code><br> -n (do not print lines)<br> -i (edit in place)</p> <p>Run the command to see what would happen (it won’t change the file)<br> Then add “-i” and run the command to update it<br> (or “-iBU” to create a new file with “BU” at the end)<br> g (at the end means global across the entire text)<br> -r (use egrep or extended grep)<br> Note - the delimiter does not have to be /. The first character after “s” is the delimiter. So the delimiter can be a space, underscore, comma, etc. This is useful to make scripts simpler to read depending on your string.</p> <p>Can change “RPM” to “rpm”<br> <code class="language-plaintext highlighter-rouge">$ sed -i 's/RPM/rpm/' sensors.log</code></p> <p>Remove the “+” in front of the temps<br> <code class="language-plaintext highlighter-rouge">$ sed -i 's/+//' sensors.log</code></p> <p>Create a backup when running<br> <code class="language-plaintext highlighter-rouge">$ sed -niBU 's/RPM/rpm/' sensors.log</code></p> <p>Replace dell and Dell with HP<br> <code class="language-plaintext highlighter-rouge">$ sed 's/[dD]ell/HP/' sensors.log</code><br> Can specify a line or range of lines to limit the replacement to<br> <code class="language-plaintext highlighter-rouge">$ sed '1,3 s/[dD]ell/HP/' sensors.log</code></p> <p>Replacing a space / / with nothing //. The g tells it globally across the entire text.<br> <code class="language-plaintext highlighter-rouge">$ sed 's/ //g'</code><br> Replace multiple spaces with []<br> <code class="language-plaintext highlighter-rouge">$ sed 's/[ ]/ /g'</code><br> or <code class="language-plaintext highlighter-rouge">$ sed 's/[ ]\+/ /g'</code></p> <p>Example with file “html”<br> <code class="language-plaintext highlighter-rouge">$ cat html</code></p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">    &lt;td&gt;</span>data1&lt;/td&gt;
<span class="gp">              &lt;td&gt;</span>data2&lt;/td&gt;
<span class="gp">       &lt;td&gt;</span>data3&lt;/td&gt;
</code></pre></div></div> <p>To remove spaces<br> <code class="language-plaintext highlighter-rouge">$ sed -i 's/[ ]/ /g' html</code><br> To remove the <strong>td</strong> and <strong>/td</strong>. Make it easier to view by changing delimiter to _ and use -r for extended regexp (egrep). Now you don’t have to escape the ? to indicate the preceding / is optional. Both <strong>td</strong> and <strong>/td</strong> will match<br> <code class="language-plaintext highlighter-rouge">$ sed -ri 's_&lt;/?td&gt;__g' html</code><br> <code class="language-plaintext highlighter-rouge">$ cat html</code></p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">data1  
data2  
data3  
</span></code></pre></div></div> <p>the regex version would be<br> <code class="language-plaintext highlighter-rouge">$ sed -i 's_&lt;/\?td&gt;__g' html</code></p> <hr> <h1 id="helpful-terminal-commands">Helpful Terminal Commands</h1> <p>When you run a command like ‘ls’, ‘cd’, ‘cp’, etc you are calling a binary/executable file to perform some function (list contents, change directory, copy a file, etc). Similar to if you created a shell/python script and made it executable from any location (see Advanced section below for more on that)</p> <p><a href="https://magpi.raspberrypi.com/books/command-line-second-edition" target="_blank" rel="noopener noreferrer">Magpi</a>​ has a good article on command lines but below are some quick ones..</p> <p>Two very helpful command line cheats As you start typing a dir/file you can hit the tab button and it will auto-complete (as far as it is unique). Hit tab twice quickly to see matches. The terminal keeps a history of commands you typed. Just hit up/down arrow to scroll thru them.</p> <p>Most important command if you’re new to the terminal is “man”. An interface to the on-line reference manuals.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">man &lt;command&gt;</code><br> To show pages the command is on</li> <li><code class="language-plaintext highlighter-rouge">man -f &lt;command&gt;</code></li> <li> <code class="language-plaintext highlighter-rouge">man -f daemon</code><br> daemon (7) - Writing and packaging system daemons<br> daemon (3) - run in the background<br> Then to view that page</li> <li><code class="language-plaintext highlighter-rouge">man 7 daemon</code></li> </ul> <p>Commands to frequently run and keep your system up-to-date</p> <ul> <li> <code class="language-plaintext highlighter-rouge">sudo apt update &amp;&amp; sudo apt upgrade -y</code><br> (or full-upgrade which will remove packages if needed to update the whole system. Confirm which packages will be removed)</li> <li> <code class="language-plaintext highlighter-rouge">sudo apt-get install -f </code>(fix partial upgrades)</li> <li> <p><code class="language-plaintext highlighter-rouge">sudo killall apt apt-get</code>(kill all running process)</p> </li> <li><code class="language-plaintext highlighter-rouge">date</code></li> <li> <code class="language-plaintext highlighter-rouge">cal</code> <h2 id="dirfile-commands">Dir/File commands</h2> <p>​​​Directories/Files</p> </li> <li> <code class="language-plaintext highlighter-rouge">pwd</code>Display the path for the directory you are in (current working dir)</li> <li> <code class="language-plaintext highlighter-rouge">cd &lt;directory&gt;</code>Change directory</li> <li> <code class="language-plaintext highlighter-rouge">cd ~</code>Change to home directory</li> <li> <code class="language-plaintext highlighter-rouge">ls</code>List contents of directory</li> <li> <code class="language-plaintext highlighter-rouge">ls -lrt</code>(-lrt will list long, detailed, by creation time in reverse order)<br> Can use * and ? wildcards, globbing.</li> <li> <code class="language-plaintext highlighter-rouge">ls -l *text* *text*</code>glob pattern will return all files/directories with ‘text’ in the name. <br> Can use ? wildcard to indicate wild for a single character.</li> <li> <code class="language-plaintext highlighter-rouge">ls -l *.??</code>Would return all files with a 2 letter extension.</li> <li> <code class="language-plaintext highlighter-rouge">ls -la </code>See hidden files use -a (hidden files start with ‘.’)</li> <li> <code class="language-plaintext highlighter-rouge">ls -l .*text*</code>See hidden files with name ‘txt’ in them</li> <li> <table> <tbody> <tr> <td> <code class="language-plaintext highlighter-rouge">ls -lrt | more</code>If there are a lot of files can page through them (see</td> <td>or pipe usage further down)</td> </tr> </tbody> </table> </li> </ul> <p>(you may have to use sudo depending on the directories you are working with)</p> <ul> <li> <code class="language-plaintext highlighter-rouge">mkdir &lt;directory&gt;</code>Create a directory</li> <li> <code class="language-plaintext highlighter-rouge">mkdir -p &lt;directory&gt;</code>If dir already exists will create child directory inside it</li> <li> <code class="language-plaintext highlighter-rouge">touch &lt;file&gt;</code>Create a file</li> <li> <code class="language-plaintext highlighter-rouge">rm &lt;file&gt;</code>Delete file</li> <li> <code class="language-plaintext highlighter-rouge">rm -r &lt;directory/&gt;</code>Delete directory and its contents (-r is recursive)</li> <li> <code class="language-plaintext highlighter-rouge">rm -rf &lt;directory/&gt;</code>Remove directory recursively and forcibly</li> <li> <code class="language-plaintext highlighter-rouge">mv &lt;old file&gt; &lt;new file&gt;</code>Change name of a file</li> <li> <code class="language-plaintext highlighter-rouge">mv &lt;file&gt; &lt;destination directory&gt;</code> Move a file</li> <li> <code class="language-plaintext highlighter-rouge">cp &lt;file&gt; &lt;destination directory&gt;</code>Copy a file</li> <li> <code class="language-plaintext highlighter-rouge">cat &lt;file&gt;</code>Display contents of a file</li> <li> <code class="language-plaintext highlighter-rouge">less &lt;file&gt;</code>Display contents by page</li> </ul> <h2 id="pipegrep">Pipe/grep</h2> <p>Using Pipe | and grep for Advanced Text Searches<br> grep is used to search for a text match in the contents of files (using regular expression). There are many grep options but here are a few common tools for matching text in a file.<br> Don’t forget <code class="language-plaintext highlighter-rouge">man grep</code> and <code class="language-plaintext highlighter-rouge">$ info grep​</code></p> <p>Basic syntax</p> <ul> <li><code class="language-plaintext highlighter-rouge">grep [options] pattern [file]</code></li> </ul> <p>Some options<br> -r (Recursive. Search inside directories, too)<br> -i (Not case sensitive)<br> -w (Match the exact word)<br> -v (Inverse, show lines without that string)<br> -n (Display the line number the match was found)<br> Returns matching line plus a number of lines before(B), after(A), or both (C)<br> -B1<br> -A1<br> -C1</p> <p>Pattern expressions<br> . = match any single character, but must be a character/space there.<br> ? = preceding item is optional and will be matched at most once<br> ​+ = match preceding character one or more times, but must appear once.<br> * = match preceding char zero or more times, but must have a preceding char.<br> Play with the * and ? in a test file (It’s different than globbing)</p> <ul> <li>```grep * file will have no match (no preceding character to match)</li> <li> <code class="language-plaintext highlighter-rouge">grep .* file</code> (and <code class="language-plaintext highlighter-rouge">$ grep "a*"</code>, etc) will match every line <br> ^abc starts with “abc”<br> abc$ ends with “abc”</li> </ul> <p>Important note on meta-characters.</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">grep - ‘?’, ‘+’, ‘{’, ‘|’, ‘(’, and ‘)’ lose their special meaning. You need to use blackslashed versions ‘\?’, ‘\+’, ‘\{’, ‘\|’, ‘\(’, and ‘\)’. See gnu.org So OR is \|
egrep - (extended grep) you do not have to backslash. OR is simply | . This makes some expressions easier to view.
agrep - does approximate matching. You specifiy how much error with -1, -2. (example below)
</span></code></pre></div></div> <p>Using egrep to search for mulitple items (|=OR, &amp;=AND)</p> <ul> <li><code class="language-plaintext highlighter-rouge">egrep 'apple|orange|pear'</code></li> </ul> <p>Brackets - any character in the bracket can be used for matching at that position</p> <ul> <li> <code class="language-plaintext highlighter-rouge">grep 't[ow]o' "file" will find "too" and "two"</code><br> ie to find various methods of temp (ie 32°C or 32C or 32 C)<br> Search for any number, space or ° before a “C”<br> ​* <code class="language-plaintext highlighter-rouge">grep '[0-9° ]C' "file"</code> </li> </ul> <p>To find all variables named “self..something..File”</p> <ul> <li> <code class="language-plaintext highlighter-rouge">grep -i "self.*file" *</code><br> To only find variables with three character and then “File”</li> </ul> <p>To find any line with an opening and closing parenthesis () in all (*) files.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">grep '(.*)' *</code><br> To find any line with () but only letters and single space inside, no numbers<br> Note there is a space after the “z”</li> <li> <code class="language-plaintext highlighter-rouge">grep '([A-Za-z ]*)' "file"</code><br> To find only lines that start with a Capital letter (headings) can use either</li> <li> <code class="language-plaintext highlighter-rouge">grep '^[A-Z]' "file"</code> or</li> <li><code class="language-plaintext highlighter-rouge">grep '^[[:upper:]]' "file"</code></li> </ul> <p>A good grep habit is to put text inside “ “ quotation marks</p> <ul> <li> <code class="language-plaintext highlighter-rouge">grep "text" &lt;file&gt;</code> Search for “text” match in <file> (current directory).</file> </li> <li> <code class="language-plaintext highlighter-rouge">grep -rl "text" /path</code> Search for “text” match at /path and recursively (-r) inside its directories.</li> <li> <code class="language-plaintext highlighter-rouge">grep -r "text" *</code> Search for “text” match inside all files and output the files plus occurrence</li> <li> <code class="language-plaintext highlighter-rouge">grep "text" * &gt; results</code> Search for “text” match inside all files and send results to file “results”</li> </ul> <p>Combine pipe | with grep for more options. The pipe | sends output of one command to another.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">&lt;cm1&gt; | &lt;cmd2&gt;</code>(Send the output of cmd1 to cmd2)</li> <li> <code class="language-plaintext highlighter-rouge">echo $PATH | grep "sbin"</code> Output contents of $PATH to grep and highlight ‘sbin’.<br> Useful way to output variables</li> <li> <code class="language-plaintext highlighter-rouge">echo $PATH | tr ":" "\n"</code> (use the ‘tr’ to replace a character with return line \n. This puts each value on a new line making it easier to view.)</li> <li> <code class="language-plaintext highlighter-rouge">ls -la ~/ | more</code> See hidden files by page</li> </ul> <p>Search for a Specific File or Directory and Compare<br> Useful commands for locating files are “find” and “locate”.</p> <p>find - can use regex as an option or pipe to grep and use regex. But results are slightly different. Create a set of test files with different extensions and test out your searches to get comfortable with it.<br> Don’t forget $ man find for more details</p> <p>Basic syntax</p> <ul> <li> <code class="language-plaintext highlighter-rouge">find /dir -name "filename"</code><br> -name (find a file by its name)<br> -iname (not case sensitive)<br> -L (follow symbolic links)<br> -type (f=file, d=directory, l=symbolic link)</li> </ul> <h2 id="findmlocate">Find/mlocate</h2> <p>Find using wildcard/globbing<br> Can use * wildcards, will only find files.<br> Quotes are important for recursive search</p> <ul> <li> <code class="language-plaintext highlighter-rouge">find . -name "file*"</code> (start search in current directory)</li> <li> <code class="language-plaintext highlighter-rouge">find / -iname "file*"</code> (start search in root directory)</li> <li> <code class="language-plaintext highlighter-rouge">find $HOME -iname "*file*.dat"</code> (start search in home directory)</li> <li> <code class="language-plaintext highlighter-rouge">find / -name "*.txt"</code> Find all files with specific extension</li> </ul> <p>find using regex option</p> <ul> <li><code class="language-plaintext highlighter-rouge">find . -regex "expression"</code></li> </ul> <p>find using pipe to grep</p> <ul> <li> <code class="language-plaintext highlighter-rouge">find . -print | grep -i "file"</code> Pipe it to grep and use regular expression. Do not need to use * wildcards, will find files and folders. -i means case-insensitive <br> see grep page for more regular expression options</li> </ul> <p>If you don’t know the exact name try “agrep”</p> <ul> <li> <code class="language-plaintext highlighter-rouge">sudo find . -print | agrep -1 "fle"</code> The -1 looks for match within one error, can do -2, etc.</li> </ul> <p>Example directory with following files<br> sensors.log<br> sensors.txt<br> sensors.log2<br> dummy<br> Use find, find/regex, find/grep</p> <ul> <li> <code class="language-plaintext highlighter-rouge">find . -name "*sensor*log"</code><br> ./sensors.log</li> <li> <code class="language-plaintext highlighter-rouge">find . -regex ".*sensor.*log"</code><br> ./sensors.log</li> <li> <code class="language-plaintext highlighter-rouge">find . -print | grep ".*sensor.*log"</code><br> ./sensor.log2 <br> ./sensors.log</li> </ul> <p>mlocate (or locate) keeps a database of path names. Returns all results starting at root.</p> <ul> <li><code class="language-plaintext highlighter-rouge">man mlocate</code></li> <li> <code class="language-plaintext highlighter-rouge">sudo updatedb</code> (update the database of path names)</li> <li><code class="language-plaintext highlighter-rouge">mlocate "file"</code></li> <li> <code class="language-plaintext highlighter-rouge">mlocate -b "\filename"</code> (must exactly match file)</li> <li> <code class="language-plaintext highlighter-rouge">mlocate --regex "file"</code> (use regular expression)</li> <li> <code class="language-plaintext highlighter-rouge">mlocate --regex ".*flatpak.png"</code> (file flatpak.png icon)</li> </ul> <p>For visual tree</p> <ul> <li><code class="language-plaintext highlighter-rouge">tree -P "*file"</code></li> <li> <code class="language-plaintext highlighter-rouge">tree -Pa "*file"</code> Include hidden files</li> </ul> <p>grep options useful if searching for files<br> -r (recursive)<br> -H (list filename)</p> <ul> <li> <code class="language-plaintext highlighter-rouge">wc -l</code> dummy.txt Number of lines in the file (-w for words, -m for count of characters)</li> <li><code class="language-plaintext highlighter-rouge">ls / | wc -l</code></li> <li><code class="language-plaintext highlighter-rouge">ls . | wc -l</code></li> </ul> <p>To compare two files side by side</p> <ul> <li> <code class="language-plaintext highlighter-rouge">diff -y &lt;file1&gt; &lt;file2&gt;</code><br> (gui versions you can install are Kompare, Meld, Diffuse)</li> </ul> <p>Search for Programs, Apps, Executables<br> For program version</p> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;programname&gt; -V</code></li> <li><code class="language-plaintext highlighter-rouge">&lt;programname&gt; --version</code></li> </ul> <p>See if a program is running</p> <ul> <li> <code class="language-plaintext highlighter-rouge">ps aux | grep &lt;program name&gt;</code><br> See all programs running</li> <li> <code class="language-plaintext highlighter-rouge">ps -A</code><br> Can kill a program with</li> <li><code class="language-plaintext highlighter-rouge">kill -9 &lt;PID&gt; or $ kill -kill &lt;PID&gt;</code></li> <li> <code class="language-plaintext highlighter-rouge">killall &lt;name&gt; (kill by program name)</code> or</li> <li> <code class="language-plaintext highlighter-rouge">pkill &lt;program&gt;</code><br> more details with</li> <li><code class="language-plaintext highlighter-rouge">ps aux</code></li> </ul> <p>To start a job in the background use &amp;</p> <ul> <li> <code class="language-plaintext highlighter-rouge">program &amp;</code><br> (ie $ mpg321 file.mp3 &amp;)<br> To see jobs running</li> <li> <code class="language-plaintext highlighter-rouge">jobs</code><br> Then to kill it</li> <li><code class="language-plaintext highlighter-rouge">kill %1</code></li> </ul> <p>Find program type and location<br> which will return the path name of the program that would be executed if found in $PATH</p> <ul> <li> <code class="language-plaintext highlighter-rouge">which &lt;programname&gt;</code><br> To show all matching executables use -a</li> <li> <code class="language-plaintext highlighter-rouge">which -a &lt;programname&gt;</code><br> whereis attempts to locate the desired program in the standard Linux places, and in the places specified by $PATH and $MANPATH. It is used to find binary, source, and man pages.</li> <li> <code class="language-plaintext highlighter-rouge">whereis &lt;programname&gt;​</code><br> options -b (binary) -s (source) -m (man pages)</li> <li> <code class="language-plaintext highlighter-rouge">whereis -b &lt;programname&gt;</code><br> Output Command, Environment Variables to Text <br> ​The &gt; sends output of a command to a file</li> <li> <code class="language-plaintext highlighter-rouge">&lt;command&gt; &gt; &lt;file&gt;</code> Output command result to file<br> example $ echo $PATH &gt; test will output the contents of $PATH to ‘test’ file</li> <li> <code class="language-plaintext highlighter-rouge">&lt;command&gt; &gt;&gt; &lt;file&gt;</code> Append the output of command to file</li> </ul> <p>Environment Variables</p> <ul> <li> <code class="language-plaintext highlighter-rouge">env</code> To see list of variables</li> <li> <code class="language-plaintext highlighter-rouge">echo $PATH</code> To output variable value</li> </ul> <h2 id="globbing">globbing</h2> <p>globbing vs regular expression<br> When researching wildcard/matching you may come across the terms globbing and regular expression (regex)<br> Globbing filenames is a simpler method of using * and ? wild cards<br> * = match 0 or more characters<br> ? = match a single character<br> Regex is used in commands for pattern matching in text and has more complex options. A good tutorial to learn how it works is <a href="https://regexone.com/" target="_blank" rel="noopener noreferrer">regexone</a><br> Running Command with sudo/root<br> Running commands from root (see sudo section for more details)<br> Most common, temporary method, is</p> <ul> <li> <code class="language-plaintext highlighter-rouge">sudo &lt;command&gt;</code><br> To stay as root run<br> <code class="language-plaintext highlighter-rouge">sudo -i</code>or <code class="language-plaintext highlighter-rouge">sudo su -</code> or <code class="language-plaintext highlighter-rouge">sudo -s</code> <br> (su is used to change users)<br> To run previous command with sudo</li> <li> <code class="language-plaintext highlighter-rouge">sudo !!</code><br> Get Operating System and Hardware Info (lsb_release)<br> ​Couple quick options to see what operating system release you’re running (helpful when installing programs)</li> <li><code class="language-plaintext highlighter-rouge">lscpu</code></li> <li><code class="language-plaintext highlighter-rouge">lsb_release -a​​</code></li> <li> <code class="language-plaintext highlighter-rouge">lsb_release -cs</code> (code name)</li> <li><code class="language-plaintext highlighter-rouge">cat /etc/os-release</code></li> <li> <code class="language-plaintext highlighter-rouge">cat /proc/cpuinfo uname -a</code><br> More detailed info on RPi</li> <li><code class="language-plaintext highlighter-rouge">sudo apt install raspinfo</code></li> <li><code class="language-plaintext highlighter-rouge">raspinfo</code></li> <li><code class="language-plaintext highlighter-rouge">sudo apt-get install lshw</code></li> <li><code class="language-plaintext highlighter-rouge">sudo lshw​</code></li> </ul> <p>Another option that gives a summary is neofetch or screenfetch</p> <ul> <li><code class="language-plaintext highlighter-rouge">sudo apt install neofetch To install</code></li> <li> <code class="language-plaintext highlighter-rouge">neofetch To get details on system</code><br> (for screenfetch, same commands, just replace with screenfetch)<br> DE = Desktop Environment<br> WM = Windows Manager</li> </ul> <p>Disk Usage</p> <ul> <li><code class="language-plaintext highlighter-rouge">df -h</code></li> </ul> <hr> <hr> <p><a href="../../../ref/linux//">Scratch Tutorials</a></p> <div class="row"> <div class="col-md mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/linux/.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="row justify-content-center float-right"> <div class="col-4-auto mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/linux/.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <hr> <p>Images can you col-# col-sm-# col-md-# col-lg-# Use auto to auto size around image Just wrap your images with <code class="language-plaintext highlighter-rouge">&lt;div class="col-sm"&gt;</code> and place them inside <code class="language-plaintext highlighter-rouge">&lt;div class="row"&gt;</code> (read more about the <a href="https://getbootstrap.com/docs/4.4/layout/grid/" target="_blank" rel="noopener noreferrer">Bootstrap Grid</a> system).</p> </article> </div> </main> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Sean Trautman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>